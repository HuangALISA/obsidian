Поля класса — это переменные, содержащие определенную информацию. Поля могут быть разделены на две группы:  
  

1.  Поля экземпляров класса
2.  Поля самого класса (статические)

  
Поля также имеют два уровня доступа:  
  

1.  Открытые (публичные): поля доступны как внутри класса, так и в экзмеплярах
2.  Частные (приватные): поля доступны только внутри класса

  

### 3.1. Открытые поля экземпляров класса

  

```
class User {
    constructor(name) {
        this.name = name
    }
}
```

  
Выражение this.name = name создает поле экземпляра name и присваивает ему начальное значение.  
  
Доступ к этому полю можно получить с помощью аксессора свойства:  
  

```
const user = new User('Печорин')
user.name // Печорин
```

  
В данном случае name — открытое поле, поскольку оно доступно за пределами класса User.  
  
При неявном создании полей внутри конструктора, сложно получить список всех полей. Для этого поля нужно извлекать из конструктора.  
  
Лучшим способом является явное определение полей класса. Неважно, что делает конструктор, экземпляр всегда имеет одинаковый набор полей.  
  
[Предложение по созданию полей класса](https://github.com/tc39/proposal-class-fields) позволяет определять поля внутри класса. Кроме того, здесь же можно присваивать полям начальные значения:  
  

```
class SomeClass {
    field1
    field2 = 'Начальное значение'

    // ...
}
```

  
Изменим код класса User, определив в нем открытое поле name:  
  

```
class User {
    name

    constructor(name) {
        this.name = name
    }
}

const user = new User('Печорин')
user.name // Печорин
```

  
Такие открытые поля являются очень наглядными, быстрый взгляд на класс позволяет понять структуру его данных.  
  
Более того, поле класса может быть инициализировано в момент определения:  
  

```
class User {
    name = 'Имярек'

    constructor() {
        // инициализация отсутствует
    }
}

const user = new User()
user.name // Имярек
```

  
На доступ к открытым полям и их изменение нет ограничений. Читать и присваивать значения таким полям можно в конструкторе, методах и за пределами класса.  
  

### 3.2. Частные поля экземпляров класса

  
Инкапсуляция позволяет скрывать внутренние детали реализации класса. Тот, кто использует инкапсулированный класс, опирается на публичный интерфейс, не вдаваясь в подробности реализации класса.  
  
Такие классы проще обновлять при изменении деталей реализации.  
  
Хорошим способом скрыть детали является использование частных полей. Такие поля могут быть прочитаны и изменены только внутри класса, которому они принадлежат. За пределами класса частные поля недоступны.  
  
Для того, чтобы сделать поле частным, перед его названием следует поставить символ #, например, #myPrivateField. При обращении к такому полю всегда должен использоваться указанный префикс.  
  
Сделаем поле name частным:  
  

```
class User {
    #name

    constructor(name) {
        this.#name = name
    }

    getName() {
        return this.#name
    }
}

const user = new User('Печорин')
user.getName() // Печорин
user.#name // SyntaxError
```

  
#name — частное поле. Доступ к нему можно получить только внутри класса User. Это позволяет сделать метод getName().  
  
Однако, при попытке получить доступ к #name за пределами класса User будет выброшена синтаксическая ошибка: SyntaxError: Private field '#name' must be declared in an enclosing class.  
  

### 3.3. Открытые статические поля

  
В классе можно определить поля, принадлежащие самому классу: статические поля. Такие поля используются для создания констант, хранящих нужную классу информацию.  
  
Для создания статических полей используется ключевое слово static перед названием поля: static myStaticField.  
  
Добавим новое поле type для определения типа пользователя: администратора или обычного. Статические поля TYPE_ADMIN и TYPE_REGULAR — константы для каждого типа пользователей:  
  

```
class User {
    static TYPE_ADMIN = 'admin'
    static TYPE_REGULAR = 'regular'

    name
    type

    constructor(name, type) {
        this.name = name
        this.type = type
    }
}

const admin = new User('Администратор сайта', User.TYPE_ADMIN)
admin.type === User.TYPE_ADMIN // true
```

  
Для доступа к статическим полям следует использовать название класса и название свойства: User.TYPE_ADMIN и User.TYPE_REGULAR.  
  

### 3.4. Частные статические поля

  
Иногда статические поля также являются частью внутренней реализации класса. Для инкапсуляции таких полей можно сделать их частными.  
  
Для этого следует перед названием поля поставить префикс #: static #myPrivateStaticFiled.  
  
Предположим, что мы хотим ограничить количество экземпляров класса User. Для сокрытия информации о количестве экземпляров можно создать частные статические поля:  
  

```
class User {
    static #MAX_INSTANCES = 2
    static #instances = 0

    name

    constructor(name) {
        User.#instances++
        if (User.#instances > User.#MAX_INSTANCES) {
            throw new Error('Невозможно создать экземпляр класса User')
        }
        this.name = name
    }
}

new User('Печорин')
new User('Бэла')
new User('Грушницкий') // Невозможно создать экземпляр класса User
```

  
Статическое поле User.#MAX_INSTANCES определяет допустимое количество экземпляров, а User.#instances — количество созданных экземпляров.  
  
Эти частные статические поля доступны только внутри класса User. Ничто из внешнего мира не может повлиять на ограничения: в этом заключается одно из преимуществ инкапсуляции.  
  
Прим. пер.: если ограничить количество экземпляров одним, получится интересная реализация шаблона проектирования «Одиночка» (Singleton).


[[this]]